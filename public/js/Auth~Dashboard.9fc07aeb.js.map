{"version":3,"sources":["webpack:///./node_modules/vee-validate/dist/vee-validate.esm.js"],"names":["isCallable","fn","isObject","obj","Array","isArray","RULES","resolveRule","id","isLocator","value","__locatorRef","isHTMLTag","tag","includes","isFileInput","type","isYupValidator","validate","hasCheckedAttr","isIndex","Number","isEmptyContainer","length","Object","keys","isNotNestedPath","path","test","cleanupNonNestedPath","replace","getFromPath","object","split","filter","Boolean","reduce","acc","propKey","setInPath","i","unset","key","splice","unsetPath","pathValues","map","_","idx","slice","join","keysOf","record","isEvent","evt","Event","srcElement","normalizeEventValue","input","target","_value","files","from","normalizeRules","rules","defineProperty","writable","enumerable","configurable","_$$isNormalized","prev","curr","params","normalizeParams","buildParams","rule","parsedRule","parseRule","name","provided","mapValueToLocator","createLocator","locator","crossTable","val","extractLocators","normalizeChildren","context","slotProps","slots","default","DEFAULT_CONFIG","generateMessage","field","bails","validateOnBlur","validateOnChange","validateOnInput","validateOnModelUpdate","currentConfig","assign","getConfig","async","options","shouldBail","formData","values","result","_validate","errors","validateFieldWithYup","isValid","message","_generateFieldError","form","_test","error","push","abortEarly","then","catch","err","validator","Error","fillTargetValues","ctx","undefined","fieldCtx","normalize","param","FormSymbol","Symbol","FormErrorsSymbol","FormInitialValues","useField","opts","initialValue","validateOnMount","disabled","valueProp","label","validateOnValueUpdate","normalizeOptions","injectWithSelf","meta","handleBlur","handleInput","reset","setValidationState","checked","useValidationState","initValue","nonYupSchemaRules","extractRuleFromSchema","schema","normalizedRules","validate$1","_a","pending","validateSchema","handleChange","e","_b","dirty","errorMessage","setTouched","isTouched","touched","setDirty","isDirty","deep","register","unregister","dependencies","rulesVal","deps","dep","forEach","defaults","resetFlags","useMeta","useFieldValue","valid","initialMeta","fieldName","newVal","setFieldValue","symbol","def","vm","provides","Field","inheritAttrs","props","as","String","required","Function","validateField","attrs","modelValue","isDuringValueTick","valueTick","onChangeHandler","emit","onInputHandler","makeSlotProps","fieldProps","onBlur","onInput","onChange","resolveTag","children","useForm","fields","isSubmitting","fieldsById","firstField","activeFields","formValues","group","find","f","activeFormValues","initialValues","useFormInitialValues","useFormMeta","setFieldError","fieldInstance","instance","setErrors","oldVal","indexOf","newValue","setValues","setFieldTouched","setFieldDirty","handleReset","registerField","unregisterField","valueIdx","call","formCtx","validationSchema","shouldMutate","validateYupSchema","results","every","r","Promise","all","handleSubmit","preventDefault","stopPropagation","submitForm","submit","MERGE_STRATEGIES","flags","flag","mergeMethod","inner","errorsByPath","aggregatedResult","fieldId","messages","fieldResult","isGroup","some","providedValues","isSafeToUpdate","fieldPath","isFieldDirty","Form","onSubmit","handleFormReset","onReset","handleScopedSlotSubmit","onSuccess","this","formAttrs","novalidate","ErrorMessage","role"],"mappings":"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","file":"js/Auth~Dashboard.9fc07aeb.js","sourcesContent":["/**\n  * vee-validate v4.0.0-beta.12\n  * (c) 2020 Abdelrahman Awad\n  * @license MIT\n  */\nimport { inject, unref, computed, onMounted, watch, isRef, onBeforeUnmount, watchEffect, ref, reactive, getCurrentInstance, defineComponent, toRef, nextTick, h, provide } from 'vue';\n\nfunction isCallable(fn) {\r\n    return typeof fn === 'function';\r\n}\r\nconst isObject = (obj) => obj !== null && obj && typeof obj === 'object' && !Array.isArray(obj);\n\nconst RULES = {};\r\n/**\r\n * Adds a custom validator to the list of validation rules.\r\n */\r\nfunction defineRule(id, validator) {\r\n    // makes sure new rules are properly formatted.\r\n    guardExtend(id, validator);\r\n    RULES[id] = validator;\r\n}\r\n/**\r\n * Gets an already defined rule\r\n */\r\nfunction resolveRule(id) {\r\n    return RULES[id];\r\n}\r\n/**\r\n * Guards from extension violations.\r\n */\r\nfunction guardExtend(id, validator) {\r\n    if (isCallable(validator)) {\r\n        return;\r\n    }\r\n    throw new Error(`Extension Error: The validator '${id}' must be a function.`);\r\n}\n\nfunction isLocator(value) {\r\n    return isCallable(value) && !!value.__locatorRef;\r\n}\r\n/**\r\n * Checks if an tag name is a native HTML tag and not a Vue component\r\n */\r\nfunction isHTMLTag(tag) {\r\n    return ['input', 'textarea', 'select'].includes(tag);\r\n}\r\n/**\r\n * Checks if an input is of type file\r\n */\r\nfunction isFileInput(tag, type) {\r\n    return isHTMLTag(tag) && type === 'file';\r\n}\r\nfunction isYupValidator(value) {\r\n    return value && isCallable(value.validate);\r\n}\r\nfunction hasCheckedAttr(type) {\r\n    return type === 'checkbox' || type === 'radio';\r\n}\r\nfunction isIndex(value) {\r\n    return Number(value) >= 0;\r\n}\r\n/**\r\n * True if the value is an empty object or array\r\n */\r\nfunction isEmptyContainer(value) {\r\n    if (Array.isArray(value)) {\r\n        return value.length === 0;\r\n    }\r\n    return isObject(value) && Object.keys(value).length === 0;\r\n}\r\n/**\r\n * Checks if the path opted out of nested fields using `[fieldName]` syntax\r\n */\r\nfunction isNotNestedPath(path) {\r\n    return /^\\[.+\\]$/i.test(path);\r\n}\n\nfunction cleanupNonNestedPath(path) {\r\n    if (isNotNestedPath(path)) {\r\n        return path.replace(/\\[|\\]/gi, '');\r\n    }\r\n    return path;\r\n}\r\n/**\r\n * Gets a nested property value from an object\r\n */\r\nfunction getFromPath(object, path) {\r\n    if (!object) {\r\n        return undefined;\r\n    }\r\n    if (isNotNestedPath(path)) {\r\n        return object[cleanupNonNestedPath(path)];\r\n    }\r\n    return path\r\n        .split(/\\.|\\[(\\d+)\\]/)\r\n        .filter(Boolean)\r\n        .reduce((acc, propKey) => {\r\n        if (acc && propKey in acc) {\r\n            return acc[propKey];\r\n        }\r\n        return undefined;\r\n    }, object);\r\n}\r\n/**\r\n * Sets a nested property value in a path, creates the path properties if it doesn't exist\r\n */\r\nfunction setInPath(object, path, value) {\r\n    if (isNotNestedPath(path)) {\r\n        object[cleanupNonNestedPath(path)] = value;\r\n        return;\r\n    }\r\n    const keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\r\n    let acc = object;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        // Last key, set it\r\n        if (i === keys.length - 1) {\r\n            acc[keys[i]] = value;\r\n            return;\r\n        }\r\n        // Key does not exist, create a container for it\r\n        if (!(keys[i] in acc)) {\r\n            // container can be either an object or an array depending on the next key if it exists\r\n            acc[keys[i]] = isIndex(keys[i + 1]) ? [] : {};\r\n        }\r\n        acc = acc[keys[i]];\r\n    }\r\n}\r\nfunction unset(object, key) {\r\n    if (Array.isArray(object) && isIndex(key)) {\r\n        object.splice(Number(key), 1);\r\n        return;\r\n    }\r\n    delete object[key];\r\n}\r\n/**\r\n * Removes a nested property from object\r\n */\r\nfunction unsetPath(object, path) {\r\n    if (isNotNestedPath(path)) {\r\n        delete object[cleanupNonNestedPath(path)];\r\n        return;\r\n    }\r\n    const keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\r\n    let acc = object;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        // Last key, unset it\r\n        if (i === keys.length - 1) {\r\n            unset(acc, keys[i]);\r\n            break;\r\n        }\r\n        // Key does not exist, exit\r\n        if (!(keys[i] in acc)) {\r\n            break;\r\n        }\r\n        acc = acc[keys[i]];\r\n    }\r\n    const pathValues = keys.map((_, idx) => {\r\n        return getFromPath(object, keys.slice(0, idx).join('.'));\r\n    });\r\n    for (let i = pathValues.length - 1; i >= 0; i--) {\r\n        if (!isEmptyContainer(pathValues[i])) {\r\n            continue;\r\n        }\r\n        if (i === 0) {\r\n            unset(object, keys[0]);\r\n            continue;\r\n        }\r\n        unset(pathValues[i - 1], keys[i - 1]);\r\n    }\r\n}\r\n/**\r\n * A typed version of Object.keys\r\n */\r\nfunction keysOf(record) {\r\n    return Object.keys(record);\r\n}\n\nconst isEvent = (evt) => {\r\n    if (!evt) {\r\n        return false;\r\n    }\r\n    if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {\r\n        return true;\r\n    }\r\n    // this is for IE\r\n    /* istanbul ignore next */\r\n    if (evt && evt.srcElement) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\nfunction normalizeEventValue(value) {\r\n    if (!isEvent(value)) {\r\n        return value;\r\n    }\r\n    const input = value.target;\r\n    // Vue sets the current bound value on `_value` prop\r\n    // for checkboxes it it should fetch the value binding type as is (boolean instead of string)\r\n    if (input.type === 'checkbox' && '_value' in input) {\r\n        return input._value;\r\n    }\r\n    if (input.type === 'file' && input.files) {\r\n        return Array.from(input.files);\r\n    }\r\n    return input.value;\r\n}\n\n/**\r\n * Normalizes the given rules expression.\r\n */\r\nfunction normalizeRules(rules) {\r\n    // if falsy value return an empty object.\r\n    const acc = {};\r\n    Object.defineProperty(acc, '_$$isNormalized', {\r\n        value: true,\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false,\r\n    });\r\n    if (!rules) {\r\n        return acc;\r\n    }\r\n    // If its a single validate function or a yup fn, leave as is.\r\n    if (isCallable(rules) || isYupValidator(rules)) {\r\n        return rules;\r\n    }\r\n    // Object is already normalized, skip.\r\n    if (isObject(rules) && rules._$$isNormalized) {\r\n        return rules;\r\n    }\r\n    if (isObject(rules)) {\r\n        return Object.keys(rules).reduce((prev, curr) => {\r\n            const params = normalizeParams(rules[curr]);\r\n            if (rules[curr] !== false) {\r\n                prev[curr] = buildParams(params);\r\n            }\r\n            return prev;\r\n        }, acc);\r\n    }\r\n    /* istanbul ignore if */\r\n    if (typeof rules !== 'string') {\r\n        return acc;\r\n    }\r\n    return rules.split('|').reduce((prev, rule) => {\r\n        const parsedRule = parseRule(rule);\r\n        if (!parsedRule.name) {\r\n            return prev;\r\n        }\r\n        prev[parsedRule.name] = buildParams(parsedRule.params);\r\n        return prev;\r\n    }, acc);\r\n}\r\n/**\r\n * Normalizes a rule param.\r\n */\r\nfunction normalizeParams(params) {\r\n    if (params === true) {\r\n        return [];\r\n    }\r\n    if (Array.isArray(params)) {\r\n        return params;\r\n    }\r\n    if (isObject(params)) {\r\n        return params;\r\n    }\r\n    return [params];\r\n}\r\nfunction buildParams(provided) {\r\n    const mapValueToLocator = (value) => {\r\n        // A target param using interpolation\r\n        if (typeof value === 'string' && value[0] === '@') {\r\n            return createLocator(value.slice(1));\r\n        }\r\n        return value;\r\n    };\r\n    if (Array.isArray(provided)) {\r\n        return provided.map(mapValueToLocator);\r\n    }\r\n    return Object.keys(provided).reduce((prev, key) => {\r\n        prev[key] = mapValueToLocator(provided[key]);\r\n        return prev;\r\n    }, {});\r\n}\r\n/**\r\n * Parses a rule string expression.\r\n */\r\nconst parseRule = (rule) => {\r\n    let params = [];\r\n    const name = rule.split(':')[0];\r\n    if (rule.includes(':')) {\r\n        params = rule.split(':').slice(1).join(':').split(',');\r\n    }\r\n    return { name, params };\r\n};\r\nfunction createLocator(value) {\r\n    const locator = (crossTable) => {\r\n        const val = crossTable[value];\r\n        return val;\r\n    };\r\n    locator.__locatorRef = value;\r\n    return locator;\r\n}\r\nfunction extractLocators(params) {\r\n    if (Array.isArray(params)) {\r\n        return params.filter(isLocator);\r\n    }\r\n    return Object.keys(params)\r\n        .filter(key => isLocator(params[key]))\r\n        .map(key => params[key]);\r\n}\n\nconst normalizeChildren = (context, slotProps) => {\r\n    if (!context.slots.default) {\r\n        return [];\r\n    }\r\n    return context.slots.default(slotProps) || [];\r\n};\n\nconst DEFAULT_CONFIG = {\r\n    generateMessage: ({ field }) => `${field} is not valid.`,\r\n    bails: true,\r\n    validateOnBlur: true,\r\n    validateOnChange: true,\r\n    validateOnInput: false,\r\n    validateOnModelUpdate: true,\r\n};\r\nlet currentConfig = Object.assign({}, DEFAULT_CONFIG);\r\nconst getConfig = () => currentConfig;\r\nconst setConfig = (newConf) => {\r\n    currentConfig = Object.assign(Object.assign({}, currentConfig), newConf);\r\n};\r\nconst configure = setConfig;\n\n/**\r\n * Validates a value against the rules.\r\n */\r\nasync function validate(value, rules, options = {}) {\r\n    const shouldBail = options === null || options === void 0 ? void 0 : options.bails;\r\n    const field = {\r\n        name: (options === null || options === void 0 ? void 0 : options.name) || '{field}',\r\n        rules: normalizeRules(rules),\r\n        bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,\r\n        formData: (options === null || options === void 0 ? void 0 : options.values) || {},\r\n    };\r\n    const result = await _validate(field, value);\r\n    const errors = result.errors;\r\n    return {\r\n        errors,\r\n    };\r\n}\r\n/**\r\n * Starts the validation process.\r\n */\r\nasync function _validate(field, value) {\r\n    if (isYupValidator(field.rules)) {\r\n        return validateFieldWithYup(field, value);\r\n    }\r\n    // if a generic function, use it as the pipeline.\r\n    if (isCallable(field.rules)) {\r\n        const result = await field.rules(value);\r\n        const isValid = typeof result !== 'string' && result;\r\n        const message = typeof result === 'string'\r\n            ? result\r\n            : _generateFieldError({\r\n                field: field.name,\r\n                value,\r\n                form: field.formData,\r\n            });\r\n        return {\r\n            errors: !isValid ? [message] : [],\r\n        };\r\n    }\r\n    const errors = [];\r\n    const rules = Object.keys(field.rules);\r\n    const length = rules.length;\r\n    for (let i = 0; i < length; i++) {\r\n        const rule = rules[i];\r\n        const result = await _test(field, value, {\r\n            name: rule,\r\n            params: field.rules[rule],\r\n        });\r\n        if (result.error) {\r\n            errors.push(result.error);\r\n            if (field.bails) {\r\n                return {\r\n                    errors,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        errors,\r\n    };\r\n}\r\n/**\r\n * Handles yup validation\r\n */\r\nasync function validateFieldWithYup(field, value) {\r\n    const errors = await field.rules\r\n        .validate(value, {\r\n        abortEarly: field.bails,\r\n    })\r\n        .then(() => [])\r\n        .catch((err) => {\r\n        // Yup errors have a name prop one them.\r\n        // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\r\n        if (err.name === 'ValidationError') {\r\n            return err.errors;\r\n        }\r\n        // re-throw the error so we don't hide it\r\n        throw err;\r\n    });\r\n    return {\r\n        errors,\r\n    };\r\n}\r\n/**\r\n * Tests a single input value against a rule.\r\n */\r\nasync function _test(field, value, rule) {\r\n    const validator = resolveRule(rule.name);\r\n    if (!validator) {\r\n        throw new Error(`No such validator '${rule.name}' exists.`);\r\n    }\r\n    const params = fillTargetValues(rule.params, field.formData);\r\n    const ctx = {\r\n        field: field.name,\r\n        value,\r\n        form: field.formData,\r\n        rule,\r\n    };\r\n    const result = await validator(value, params, ctx);\r\n    if (typeof result === 'string') {\r\n        return {\r\n            error: result,\r\n        };\r\n    }\r\n    return {\r\n        error: result ? undefined : _generateFieldError(ctx),\r\n    };\r\n}\r\n/**\r\n * Generates error messages.\r\n */\r\nfunction _generateFieldError(fieldCtx) {\r\n    const message = getConfig().generateMessage;\r\n    if (!message) {\r\n        return 'Field is invalid';\r\n    }\r\n    return message(fieldCtx);\r\n}\r\nfunction fillTargetValues(params, crossTable) {\r\n    const normalize = (value) => {\r\n        if (isLocator(value)) {\r\n            return value(crossTable);\r\n        }\r\n        return value;\r\n    };\r\n    if (Array.isArray(params)) {\r\n        return params.map(normalize);\r\n    }\r\n    return Object.keys(params).reduce((acc, param) => {\r\n        acc[param] = normalize(params[param]);\r\n        return acc;\r\n    }, {});\r\n}\n\nconst FormSymbol = Symbol('vee-validate-form');\r\nconst FormErrorsSymbol = Symbol('vee-validate-form-errors');\r\nconst FormInitialValues = Symbol('vee-validate-form-initial-values');\n\n/**\r\n * Creates a field composite.\r\n */\r\nfunction useField(name, rules, opts) {\r\n    const { initialValue, validateOnMount, bails, disabled, type, valueProp, label, validateOnValueUpdate, } = normalizeOptions(name, opts);\r\n    const form = injectWithSelf(FormSymbol, undefined);\r\n    const { meta, errors, handleBlur, handleInput, reset, setValidationState, value, checked } = useValidationState({\r\n        name,\r\n        // make sure to unref initial value because of possible refs passed in\r\n        initValue: unref(initialValue),\r\n        form,\r\n        type,\r\n        valueProp,\r\n    });\r\n    const nonYupSchemaRules = extractRuleFromSchema(form === null || form === void 0 ? void 0 : form.schema, name);\r\n    const normalizedRules = computed(() => {\r\n        return normalizeRules(nonYupSchemaRules || unref(rules));\r\n    });\r\n    const validate$1 = async () => {\r\n        var _a;\r\n        meta.pending = true;\r\n        let result;\r\n        if (!form || !form.validateSchema) {\r\n            result = await validate(value.value, normalizedRules.value, {\r\n                name: label,\r\n                values: (_a = form === null || form === void 0 ? void 0 : form.values) !== null && _a !== void 0 ? _a : {},\r\n                bails,\r\n            });\r\n        }\r\n        else {\r\n            result = (await form.validateSchema())[name];\r\n        }\r\n        meta.pending = false;\r\n        return setValidationState(result);\r\n    };\r\n    // Common input/change event handler\r\n    const handleChange = (e) => {\r\n        var _a, _b;\r\n        if (checked && checked.value === ((_b = (_a = e) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.checked)) {\r\n            return;\r\n        }\r\n        value.value = normalizeEventValue(e);\r\n        meta.dirty = true;\r\n        if (!validateOnValueUpdate) {\r\n            return validate$1();\r\n        }\r\n    };\r\n    if (validateOnMount) {\r\n        onMounted(validate$1);\r\n    }\r\n    const errorMessage = computed(() => {\r\n        return errors.value[0];\r\n    });\r\n    function setTouched(isTouched) {\r\n        meta.touched = isTouched;\r\n    }\r\n    function setDirty(isDirty) {\r\n        meta.dirty = isDirty;\r\n    }\r\n    const field = {\r\n        name,\r\n        value: value,\r\n        meta,\r\n        errors,\r\n        errorMessage,\r\n        disabled,\r\n        type,\r\n        valueProp,\r\n        checked,\r\n        idx: -1,\r\n        reset,\r\n        validate: validate$1,\r\n        handleChange,\r\n        handleBlur,\r\n        handleInput,\r\n        setValidationState,\r\n        setTouched,\r\n        setDirty,\r\n    };\r\n    if (validateOnValueUpdate) {\r\n        watch(value, validate$1, {\r\n            deep: true,\r\n        });\r\n    }\r\n    if (isRef(rules)) {\r\n        watch(rules, validate$1, {\r\n            deep: true,\r\n        });\r\n    }\r\n    // if no associated form return the field API immediately\r\n    if (!form) {\r\n        return field;\r\n    }\r\n    // associate the field with the given form\r\n    form.register(field);\r\n    onBeforeUnmount(() => {\r\n        form.unregister(field);\r\n    });\r\n    // extract cross-field dependencies in a computed prop\r\n    const dependencies = computed(() => {\r\n        const rulesVal = normalizedRules.value;\r\n        // is falsy, a function schema or a yup schema\r\n        if (!rulesVal || isCallable(rulesVal) || isCallable(rulesVal.validate)) {\r\n            return [];\r\n        }\r\n        return Object.keys(rulesVal).reduce((acc, rule) => {\r\n            const deps = extractLocators(normalizedRules.value[rule]).map((dep) => dep.__locatorRef);\r\n            acc.push(...deps);\r\n            return acc;\r\n        }, []);\r\n    });\r\n    // Adds a watcher that runs the validation whenever field dependencies change\r\n    watchEffect(() => {\r\n        // Skip if no dependencies\r\n        if (!dependencies.value.length) {\r\n            return;\r\n        }\r\n        // For each dependent field, validate it if it was validated before\r\n        dependencies.value.forEach(dep => {\r\n            if (dep in form.values && meta.dirty) {\r\n                return validate$1();\r\n            }\r\n        });\r\n    });\r\n    return field;\r\n}\r\n/**\r\n * Normalizes partial field options to include the full\r\n */\r\nfunction normalizeOptions(name, opts) {\r\n    const defaults = () => ({\r\n        initialValue: undefined,\r\n        validateOnMount: false,\r\n        bails: true,\r\n        rules: '',\r\n        disabled: false,\r\n        label: name,\r\n        validateOnValueUpdate: true,\r\n    });\r\n    if (!opts) {\r\n        return defaults();\r\n    }\r\n    return Object.assign(Object.assign({}, defaults()), (opts || {}));\r\n}\r\n/**\r\n * Manages the validation state of a field.\r\n */\r\nfunction useValidationState({ name, initValue, form, type, valueProp, }) {\r\n    var _a;\r\n    const errors = ref([]);\r\n    const initialValue = (_a = getFromPath(unref(inject(FormInitialValues, {})), name)) !== null && _a !== void 0 ? _a : initValue;\r\n    const { reset: resetFlags, meta } = useMeta(initialValue);\r\n    const value = useFieldValue(initialValue, name, form);\r\n    if (hasCheckedAttr(type) && initialValue) {\r\n        value.value = initialValue;\r\n    }\r\n    const checked = hasCheckedAttr(type)\r\n        ? computed(() => {\r\n            if (Array.isArray(value.value)) {\r\n                return value.value.includes(unref(valueProp));\r\n            }\r\n            return unref(valueProp) === value.value;\r\n        })\r\n        : undefined;\r\n    if (checked === undefined || checked.value) {\r\n        // Set the value without triggering the watcher\r\n        value.value = initialValue;\r\n    }\r\n    /**\r\n     * Handles common onBlur meta update\r\n     */\r\n    const handleBlur = () => {\r\n        meta.touched = true;\r\n    };\r\n    /**\r\n     * Handles common on blur events\r\n     */\r\n    const handleInput = (e) => {\r\n        // Checkboxes/Radio will emit a `change` event anyway, custom components will use `update:modelValue`\r\n        // so this is redundant\r\n        if (!hasCheckedAttr(type)) {\r\n            value.value = normalizeEventValue(e);\r\n        }\r\n        meta.dirty = true;\r\n    };\r\n    // Updates the validation state with the validation result\r\n    function setValidationState(result) {\r\n        errors.value = result.errors;\r\n        meta.valid = !result.errors.length;\r\n        return result;\r\n    }\r\n    // Resets the validation state\r\n    const reset = () => {\r\n        errors.value = [];\r\n        resetFlags();\r\n    };\r\n    return {\r\n        meta,\r\n        errors,\r\n        setValidationState,\r\n        reset,\r\n        handleBlur,\r\n        handleInput,\r\n        value,\r\n        checked,\r\n    };\r\n}\r\n/**\r\n * Exposes meta flags state and some associated actions with them.\r\n */\r\nfunction useMeta(initialValue) {\r\n    const initialMeta = () => ({\r\n        touched: false,\r\n        dirty: false,\r\n        valid: false,\r\n        pending: false,\r\n        initialValue,\r\n    });\r\n    const meta = reactive(initialMeta());\r\n    /**\r\n     * Resets the flag state\r\n     */\r\n    function reset() {\r\n        const defaults = initialMeta();\r\n        keysOf(meta).forEach(key => {\r\n            meta[key] = defaults[key];\r\n        });\r\n    }\r\n    return {\r\n        meta,\r\n        reset,\r\n    };\r\n}\r\n/**\r\n * Extracts the validation rules from a schema\r\n */\r\nfunction extractRuleFromSchema(schema, fieldName) {\r\n    // no schema at all\r\n    if (!schema) {\r\n        return undefined;\r\n    }\r\n    // there is a key on the schema object for this field\r\n    return schema[fieldName];\r\n}\r\n/**\r\n * Manages the field value\r\n */\r\nfunction useFieldValue(initialValue, path, form) {\r\n    // if no form is associated, use a regular ref.\r\n    if (!form) {\r\n        return ref(initialValue);\r\n    }\r\n    // set initial value\r\n    setInPath(form.values, path, initialValue);\r\n    // otherwise use a computed setter that triggers the `setFieldValue`\r\n    const value = computed({\r\n        get() {\r\n            return getFromPath(form.values, path);\r\n        },\r\n        set(newVal) {\r\n            form.setFieldValue(path, newVal);\r\n        },\r\n    });\r\n    return value;\r\n}\r\n// Uses same component provide as its own injections\r\n// Due to changes in https://github.com/vuejs/vue-next/pull/2424\r\nfunction injectWithSelf(symbol, def = undefined) {\r\n    const vm = getCurrentInstance();\r\n    return inject(symbol, def) || (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]);\r\n}\n\nconst Field = defineComponent({\r\n    name: 'Field',\r\n    inheritAttrs: false,\r\n    props: {\r\n        as: {\r\n            type: [String, Object],\r\n            default: undefined,\r\n        },\r\n        name: {\r\n            type: String,\r\n            required: true,\r\n        },\r\n        rules: {\r\n            type: [Object, String, Function],\r\n            default: null,\r\n        },\r\n        validateOnMount: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        bails: {\r\n            type: Boolean,\r\n            default: () => getConfig().bails,\r\n        },\r\n        disabled: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        label: {\r\n            type: String,\r\n            default: undefined,\r\n        },\r\n    },\r\n    setup(props, ctx) {\r\n        const [disabled, rules] = [toRef(props, 'disabled'), toRef(props, 'rules')];\r\n        const { errors, value, errorMessage, validate: validateField, handleChange, handleBlur, handleInput, setDirty, setTouched, reset, meta, checked, } = useField(props.name, rules, {\r\n            validateOnMount: props.validateOnMount,\r\n            bails: props.bails,\r\n            disabled,\r\n            type: ctx.attrs.type,\r\n            // Gets the initial value either from `value` prop/attr or `v-model` binding (modelValue)\r\n            // For checkboxes and radio buttons it will always be the model value not the `value` attribute\r\n            initialValue: hasCheckedAttr(ctx.attrs.type)\r\n                ? ctx.attrs.modelValue\r\n                : 'modelValue' in ctx.attrs\r\n                    ? ctx.attrs.modelValue\r\n                    : ctx.attrs.value,\r\n            // Only for checkboxes and radio buttons\r\n            valueProp: ctx.attrs.value,\r\n            label: props.label || props.name,\r\n            validateOnValueUpdate: false,\r\n        });\r\n        let isDuringValueTick = false;\r\n        // Prevents re-render updates that rests value when using v-model (#2941)\r\n        function valueTick() {\r\n            isDuringValueTick = true;\r\n            nextTick(() => {\r\n                isDuringValueTick = false;\r\n            });\r\n        }\r\n        // If there is a v-model applied on the component we need to emit the `update:modelValue` whenever the value binding changes\r\n        const onChangeHandler = 'modelValue' in ctx.attrs\r\n            ? function handleChangeWithModel(e) {\r\n                handleChange(e);\r\n                ctx.emit('update:modelValue', value.value);\r\n            }\r\n            : handleChange;\r\n        const onInputHandler = 'modelValue' in ctx.attrs\r\n            ? function handleChangeWithModel(e) {\r\n                handleInput(e);\r\n                ctx.emit('update:modelValue', value.value);\r\n            }\r\n            : handleInput;\r\n        const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = getConfig();\r\n        const makeSlotProps = () => {\r\n            const fieldProps = {\r\n                name: props.name,\r\n                disabled: props.disabled,\r\n                onBlur: [handleBlur],\r\n                onInput: [onInputHandler, valueTick],\r\n                onChange: [onInputHandler, valueTick],\r\n            };\r\n            if (validateOnInput) {\r\n                fieldProps.onInput.push(onChangeHandler);\r\n            }\r\n            if (validateOnChange) {\r\n                fieldProps.onChange.push(onChangeHandler);\r\n            }\r\n            if (validateOnBlur) {\r\n                fieldProps.onBlur.push(validateField);\r\n            }\r\n            if (validateOnModelUpdate) {\r\n                fieldProps['onUpdate:modelValue'] = [onChangeHandler, valueTick];\r\n            }\r\n            if (hasCheckedAttr(ctx.attrs.type) && checked) {\r\n                fieldProps.checked = checked.value;\r\n            }\r\n            else {\r\n                fieldProps.value = value.value;\r\n            }\r\n            if (isFileInput(resolveTag(props, ctx), ctx.attrs.type)) {\r\n                delete fieldProps.value;\r\n            }\r\n            return {\r\n                field: fieldProps,\r\n                meta,\r\n                errors: errors.value,\r\n                errorMessage: errorMessage.value,\r\n                validate: validateField,\r\n                reset,\r\n                handleChange: onChangeHandler,\r\n                handleInput: onInputHandler,\r\n                handleBlur,\r\n                setDirty,\r\n                setTouched,\r\n            };\r\n        };\r\n        return () => {\r\n            const tag = resolveTag(props, ctx);\r\n            const slotProps = makeSlotProps();\r\n            // Sync the model value with the inner field value if they mismatch\r\n            // a simple string comparison is used here\r\n            // make sure to check if the re-render isn't caused by a value update tick\r\n            if ('modelValue' in ctx.attrs && String(ctx.attrs.modelValue) !== String(value.value) && !isDuringValueTick) {\r\n                nextTick(() => {\r\n                    handleChange(ctx.attrs.modelValue);\r\n                });\r\n            }\r\n            const children = normalizeChildren(ctx, slotProps);\r\n            if (tag) {\r\n                return h(tag, Object.assign(Object.assign({}, ctx.attrs), slotProps.field), children);\r\n            }\r\n            return children;\r\n        };\r\n    },\r\n});\r\nfunction resolveTag(props, ctx) {\r\n    let tag = props.as || '';\r\n    if (!props.as && !ctx.slots.default) {\r\n        tag = 'input';\r\n    }\r\n    return tag;\r\n}\n\nfunction useForm(opts) {\r\n    // A flat array containing field references\r\n    const fields = ref([]);\r\n    // If the form is currently submitting\r\n    const isSubmitting = ref(false);\r\n    // a field map object useful for faster access of fields\r\n    const fieldsById = computed(() => {\r\n        return fields.value.reduce((acc, field) => {\r\n            // if the field was not added before\r\n            if (!acc[field.name]) {\r\n                acc[field.name] = field;\r\n                field.idx = -1;\r\n                return acc;\r\n            }\r\n            // if the same name is detected\r\n            if (!Array.isArray(acc[field.name])) {\r\n                const firstField = acc[field.name];\r\n                firstField.idx = 0;\r\n                acc[field.name] = [firstField];\r\n            }\r\n            field.idx = acc[field.name].length;\r\n            acc[field.name].push(field);\r\n            return acc;\r\n        }, {});\r\n    });\r\n    // a flat array of the non-disabled\r\n    const activeFields = computed(() => {\r\n        return fields.value.filter(field => !unref(field.disabled));\r\n    });\r\n    // a private ref for all form values\r\n    const formValues = reactive({});\r\n    // an aggregation of field errors in a map object\r\n    const errors = computed(() => {\r\n        return activeFields.value.reduce((acc, field) => {\r\n            // Check if its a grouped field (checkbox/radio)\r\n            let message;\r\n            if (Array.isArray(fieldsById.value[field.name])) {\r\n                const group = fieldsById.value[field.name];\r\n                message = unref((group.find((f) => unref(f.checked)) || field).errorMessage);\r\n            }\r\n            else {\r\n                message = unref(field.errorMessage);\r\n            }\r\n            if (message) {\r\n                acc[field.name] = message;\r\n            }\r\n            return acc;\r\n        }, {});\r\n    });\r\n    // same as form values but filtered disabled fields out\r\n    const activeFormValues = computed(() => {\r\n        return activeFields.value.reduce((formData, field) => {\r\n            setInPath(formData, field.name, unref(field.value));\r\n            return formData;\r\n        }, {});\r\n    });\r\n    // initial form values\r\n    const { initialValues } = useFormInitialValues(fieldsById, formValues, opts === null || opts === void 0 ? void 0 : opts.initialValues);\r\n    // form meta aggregations\r\n    const meta = useFormMeta(fields, initialValues);\r\n    /**\r\n     * Manually sets an error message on a specific field\r\n     */\r\n    function setFieldError(field, message) {\r\n        const fieldInstance = fieldsById.value[field];\r\n        if (!fieldInstance) {\r\n            return;\r\n        }\r\n        if (Array.isArray(fieldInstance)) {\r\n            fieldInstance.forEach(instance => {\r\n                instance.setValidationState({ errors: [message] });\r\n            });\r\n            return;\r\n        }\r\n        fieldInstance.setValidationState({ errors: [message] });\r\n    }\r\n    /**\r\n     * Sets errors for the fields specified in the object\r\n     */\r\n    function setErrors(fields) {\r\n        Object.keys(fields).forEach(field => {\r\n            setFieldError(field, fields[field]);\r\n        });\r\n    }\r\n    /**\r\n     * Sets a single field value\r\n     */\r\n    function setFieldValue(path, value) {\r\n        var _a;\r\n        const field = fieldsById.value[path];\r\n        // Multiple checkboxes, and only one of them got updated\r\n        if (Array.isArray(field) && ((_a = field[0]) === null || _a === void 0 ? void 0 : _a.type) === 'checkbox' && !Array.isArray(value)) {\r\n            const oldVal = getFromPath(formValues, path);\r\n            const newVal = Array.isArray(oldVal) ? [...oldVal] : [];\r\n            const idx = newVal.indexOf(value);\r\n            idx >= 0 ? newVal.splice(idx, 1) : newVal.push(value);\r\n            setInPath(formValues, path, newVal);\r\n            return;\r\n        }\r\n        let newValue = value;\r\n        // Single Checkbox\r\n        if ((field === null || field === void 0 ? void 0 : field.type) === 'checkbox') {\r\n            newValue = getFromPath(formValues, path) === value ? undefined : value;\r\n        }\r\n        setInPath(formValues, path, newValue);\r\n    }\r\n    /**\r\n     * Sets multiple fields values\r\n     */\r\n    function setValues(fields) {\r\n        Object.keys(fields).forEach(field => {\r\n            setFieldValue(field, fields[field]);\r\n        });\r\n    }\r\n    /**\r\n     * Sets the touched meta state on a field\r\n     */\r\n    function setFieldTouched(field, isTouched) {\r\n        const fieldInstance = fieldsById.value[field];\r\n        if (!fieldInstance) {\r\n            return;\r\n        }\r\n        if (Array.isArray(fieldInstance)) {\r\n            fieldInstance.forEach(f => f.setTouched(isTouched));\r\n            return;\r\n        }\r\n        fieldInstance.setTouched(isTouched);\r\n    }\r\n    /**\r\n     * Sets the touched meta state on multiple fields\r\n     */\r\n    function setTouched(fields) {\r\n        Object.keys(fields).forEach(field => {\r\n            setFieldTouched(field, fields[field]);\r\n        });\r\n    }\r\n    /**\r\n     * Sets the dirty meta state on a field\r\n     */\r\n    function setFieldDirty(field, isDirty) {\r\n        const fieldInstance = fieldsById.value[field];\r\n        if (!fieldInstance) {\r\n            return;\r\n        }\r\n        if (Array.isArray(fieldInstance)) {\r\n            fieldInstance.forEach(f => f.setDirty(isDirty));\r\n            return;\r\n        }\r\n        fieldInstance.setDirty(isDirty);\r\n    }\r\n    /**\r\n     * Sets the dirty meta state on multiple fields\r\n     */\r\n    function setDirty(fields) {\r\n        Object.keys(fields).forEach(field => {\r\n            setFieldDirty(field, fields[field]);\r\n        });\r\n    }\r\n    /**\r\n     * Resets all fields\r\n     */\r\n    const handleReset = () => {\r\n        fields.value.forEach((f) => f.reset());\r\n    };\r\n    function registerField(field) {\r\n        fields.value.push(field);\r\n    }\r\n    function unregisterField(field) {\r\n        var _a, _b;\r\n        const idx = fields.value.indexOf(field);\r\n        if (idx === -1) {\r\n            return;\r\n        }\r\n        fields.value.splice(idx, 1);\r\n        const fieldName = field.name;\r\n        // in this case, this is a single field not a group (checkbox or radio)\r\n        // so remove the field value key immediately\r\n        if (field.idx === -1) {\r\n            unsetPath(formValues, fieldName);\r\n            return;\r\n        }\r\n        // otherwise find the actual value in the current array of values and remove it\r\n        const valueIdx = (_b = (_a = getFromPath(formValues, fieldName)) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, unref(field.valueProp));\r\n        if (valueIdx === undefined) {\r\n            unsetPath(formValues, fieldName);\r\n            return;\r\n        }\r\n        if (valueIdx === -1) {\r\n            return;\r\n        }\r\n        if (Array.isArray(formValues[fieldName])) {\r\n            unsetPath(formValues, `${fieldName}.${valueIdx}`);\r\n            return;\r\n        }\r\n        unsetPath(formValues, fieldName);\r\n    }\r\n    const formCtx = {\r\n        register: registerField,\r\n        unregister: unregisterField,\r\n        fields: fieldsById,\r\n        values: formValues,\r\n        schema: opts === null || opts === void 0 ? void 0 : opts.validationSchema,\r\n        validateSchema: isYupValidator(opts === null || opts === void 0 ? void 0 : opts.validationSchema)\r\n            ? (shouldMutate = false) => {\r\n                return validateYupSchema(formCtx, shouldMutate);\r\n            }\r\n            : undefined,\r\n        setFieldValue,\r\n        setValues,\r\n        setErrors,\r\n        setFieldError,\r\n        setFieldTouched,\r\n        setTouched,\r\n        setFieldDirty,\r\n        setDirty,\r\n        reset: handleReset,\r\n    };\r\n    const validate = async () => {\r\n        if (formCtx.validateSchema) {\r\n            return formCtx.validateSchema(true).then(results => {\r\n                return Object.keys(results).every(r => !results[r].errors.length);\r\n            });\r\n        }\r\n        const results = await Promise.all(activeFields.value.map((f) => {\r\n            return f.validate();\r\n        }));\r\n        return results.every(r => !r.errors.length);\r\n    };\r\n    const handleSubmit = (fn) => {\r\n        return function submissionHandler(e) {\r\n            if (e instanceof Event) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n            }\r\n            isSubmitting.value = true;\r\n            return validate()\r\n                .then(result => {\r\n                if (result && typeof fn === 'function') {\r\n                    return fn(activeFormValues.value, { evt: e, form: formCtx });\r\n                }\r\n            })\r\n                .then(() => {\r\n                isSubmitting.value = false;\r\n            }, err => {\r\n                isSubmitting.value = false;\r\n                // re-throw the err so it doesn't go silent\r\n                throw err;\r\n            });\r\n        };\r\n    };\r\n    const submitForm = handleSubmit((_, { evt }) => {\r\n        var _a;\r\n        if (evt) {\r\n            (_a = evt === null || evt === void 0 ? void 0 : evt.target) === null || _a === void 0 ? void 0 : _a.submit();\r\n        }\r\n    });\r\n    // Trigger initial validation\r\n    onMounted(() => {\r\n        if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {\r\n            validate();\r\n        }\r\n    });\r\n    // Provide injections\r\n    provide(FormInitialValues, initialValues);\r\n    provide(FormSymbol, formCtx);\r\n    provide(FormErrorsSymbol, errors);\r\n    return {\r\n        errors,\r\n        meta,\r\n        values: formValues,\r\n        validate,\r\n        isSubmitting,\r\n        handleReset,\r\n        handleSubmit,\r\n        submitForm,\r\n        setFieldError,\r\n        setErrors,\r\n        setFieldValue,\r\n        setValues,\r\n        setFieldTouched,\r\n        setTouched,\r\n        setFieldDirty,\r\n        setDirty,\r\n    };\r\n}\r\n/**\r\n * Manages form meta aggregation\r\n */\r\nfunction useFormMeta(fields, initialValues) {\r\n    const MERGE_STRATEGIES = {\r\n        valid: 'every',\r\n        dirty: 'some',\r\n        touched: 'some',\r\n        pending: 'some',\r\n    };\r\n    return computed(() => {\r\n        const flags = keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {\r\n            const mergeMethod = MERGE_STRATEGIES[flag];\r\n            acc[flag] = fields.value[mergeMethod](field => field.meta[flag]);\r\n            return acc;\r\n        }, {});\r\n        return Object.assign({ initialValues: unref(initialValues) }, flags);\r\n    });\r\n}\r\nasync function validateYupSchema(form, shouldMutate = false) {\r\n    const errors = await form.schema\r\n        .validate(form.values, { abortEarly: false })\r\n        .then(() => [])\r\n        .catch((err) => {\r\n        // Yup errors have a name prop one them.\r\n        // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\r\n        if (err.name !== 'ValidationError') {\r\n            throw err;\r\n        }\r\n        // list of aggregated errors\r\n        return err.inner || [];\r\n    });\r\n    const fields = form.fields.value;\r\n    const errorsByPath = errors.reduce((acc, err) => {\r\n        acc[err.path] = err;\r\n        return acc;\r\n    }, {});\r\n    // Aggregates the validation result\r\n    const aggregatedResult = Object.keys(fields).reduce((result, fieldId) => {\r\n        const field = fields[fieldId];\r\n        const messages = (errorsByPath[fieldId] || { errors: [] }).errors;\r\n        const fieldResult = {\r\n            errors: messages,\r\n        };\r\n        result[fieldId] = fieldResult;\r\n        const isGroup = Array.isArray(field);\r\n        const isDirty = isGroup ? field.some((f) => f.meta.dirty) : field.meta.dirty;\r\n        if (!shouldMutate && !isDirty) {\r\n            return result;\r\n        }\r\n        if (isGroup) {\r\n            field.forEach((f) => f.setValidationState(fieldResult));\r\n            return result;\r\n        }\r\n        field.setValidationState(fieldResult);\r\n        return result;\r\n    }, {});\r\n    return aggregatedResult;\r\n}\r\n/**\r\n * Manages the initial values prop\r\n */\r\nfunction useFormInitialValues(fields, formValues, providedValues) {\r\n    const initialValues = computed(() => {\r\n        if (isRef(providedValues)) {\r\n            return providedValues.value;\r\n        }\r\n        return providedValues || {};\r\n    });\r\n    // Watch initial values for changes, and update the pristine (non-dirty and non-touched fields)\r\n    // we exclude dirty and untouched fields because it's unlikely you want to change the form values using initial values\r\n    // we mostly watch them for API population or newly inserted fields\r\n    watch(initialValues, value => {\r\n        const isSafeToUpdate = (f) => f.meta.dirty || f.meta.touched;\r\n        Object.keys(fields.value).forEach(fieldPath => {\r\n            const field = fields.value[fieldPath];\r\n            const isFieldDirty = Array.isArray(field) ? field.some(isSafeToUpdate) : isSafeToUpdate(field);\r\n            if (isFieldDirty) {\r\n                return;\r\n            }\r\n            const newValue = getFromPath(value, fieldPath);\r\n            setInPath(formValues, fieldPath, newValue);\r\n        });\r\n    }, {\r\n        deep: true,\r\n    });\r\n    return {\r\n        initialValues,\r\n    };\r\n}\n\nconst Form = defineComponent({\r\n    name: 'Form',\r\n    inheritAttrs: false,\r\n    props: {\r\n        as: {\r\n            type: String,\r\n            default: 'form',\r\n        },\r\n        validationSchema: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        initialValues: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        validateOnMount: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n    },\r\n    setup(props, ctx) {\r\n        const initialValues = toRef(props, 'initialValues');\r\n        const { errors, validate, handleSubmit, handleReset, values, meta, isSubmitting, submitForm, setErrors, setFieldError, setFieldValue, setValues, setFieldDirty, setDirty, setFieldTouched, setTouched, } = useForm({\r\n            validationSchema: props.validationSchema,\r\n            initialValues,\r\n            validateOnMount: props.validateOnMount,\r\n        });\r\n        const onSubmit = ctx.attrs.onSubmit ? handleSubmit(ctx.attrs.onSubmit) : submitForm;\r\n        function handleFormReset() {\r\n            handleReset();\r\n            if (typeof ctx.attrs.onReset === 'function') {\r\n                ctx.attrs.onReset();\r\n            }\r\n        }\r\n        function handleScopedSlotSubmit(evt, onSubmit) {\r\n            const onSuccess = typeof evt === 'function' && !onSubmit ? evt : onSubmit;\r\n            return handleSubmit(onSuccess)(evt);\r\n        }\r\n        return function renderForm() {\r\n            // FIXME: Hacky but cute way to expose some stuff to the rendered instance\r\n            // getCurrentInstance doesn't work with render fns, it returns the wrong instance\r\n            // we want to expose setFieldError and setErrors\r\n            if (!('setErrors' in this)) {\r\n                this.setFieldError = setFieldError;\r\n                this.setErrors = setErrors;\r\n                this.setFieldValue = setFieldValue;\r\n                this.setValues = setValues;\r\n                this.setFieldDirty = setFieldDirty;\r\n                this.setDirty = setDirty;\r\n                this.setFieldTouched = setFieldTouched;\r\n                this.setTouched = setTouched;\r\n            }\r\n            const children = normalizeChildren(ctx, {\r\n                meta: meta.value,\r\n                errors: errors.value,\r\n                values: values,\r\n                isSubmitting: isSubmitting.value,\r\n                validate,\r\n                handleSubmit: handleScopedSlotSubmit,\r\n                handleReset,\r\n                submitForm,\r\n                setErrors,\r\n                setFieldError,\r\n                setFieldValue,\r\n                setValues,\r\n                setFieldDirty,\r\n                setDirty,\r\n                setFieldTouched,\r\n                setTouched,\r\n            });\r\n            if (!props.as) {\r\n                return children;\r\n            }\r\n            // Attributes to add on a native `form` tag\r\n            const formAttrs = props.as === 'form'\r\n                ? {\r\n                    // Disables native validation as vee-validate will handle it.\r\n                    novalidate: true,\r\n                }\r\n                : {};\r\n            return h(props.as, Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), { onSubmit, onReset: handleFormReset }), children);\r\n        };\r\n    },\r\n});\n\nconst ErrorMessage = defineComponent({\r\n    props: {\r\n        as: {\r\n            type: String,\r\n            default: undefined,\r\n        },\r\n        name: {\r\n            type: String,\r\n            required: true,\r\n        },\r\n    },\r\n    setup(props, ctx) {\r\n        const errors = inject(FormErrorsSymbol, undefined);\r\n        const message = computed(() => {\r\n            return errors.value[props.name];\r\n        });\r\n        return () => {\r\n            const children = normalizeChildren(ctx, {\r\n                message: message.value,\r\n            });\r\n            const tag = props.as;\r\n            const attrs = Object.assign({ role: 'alert' }, ctx.attrs);\r\n            // If no tag was specified and there are children\r\n            // render the slot as is without wrapping it\r\n            if (!tag && children.length) {\r\n                return children;\r\n            }\r\n            // If no children in slot\r\n            // render whatever specified and fallback to a <span> with the message in it's contents\r\n            if (!children.length) {\r\n                return h(tag || 'span', attrs, message.value);\r\n            }\r\n            return h(tag, attrs, children);\r\n        };\r\n    },\r\n});\n\nexport { ErrorMessage, Field, Form, configure, defineRule, useField, useForm, validate };\n"],"sourceRoot":""}